allprojects {
    repositories {
        mavenLocal()
        jcenter()
    }

    group = "org.robolectric"
    version = thisVersion
}

buildscript {
    repositories { jcenter() }

    dependencies {
        classpath 'com.netflix.nebula:gradle-aggregate-javadocs-plugin:2.2.+'
        classpath 'ch.raffael.pegdown-doclet:pegdown-doclet:1.3'
    }
}

apply plugin: 'nebula-aggregate-javadocs'
apply plugin: 'ch.raffael.pegdown-doclet'

rootProject.gradle.projectsEvaluated {
    rootProject.tasks['aggregateJavadocs'].failOnError = false
}

task aggregateTestReports(type: TestReport) {
    def jobNumber = System.getenv('TRAVIS_JOB_NUMBER')
    if (jobNumber == null) {
        destinationDir = file("$buildDir/reports/allTests")
    } else {
        destinationDir = file("$buildDir/reports/allTests/$jobNumber")
    }
}

// for use of external initialization scripts...
project.ext.allSdks = AndroidSdk.ALL_SDKS

project(":cts:common:util") {
    apply plugin: "java"

    sourceSets.main.java.srcDirs = ['src']

    dependencies {
        compile 'com.google.guava:guava:20.0'
        compile project(':cts-support')
        compile AndroidSdk.N_MR1.coordinates
    }
}

// naming this :cts:common:device-side:util causes gradle to report a circular dependency... why?!?
project(":cts:common:device-side") {
    apply plugin: "java"

    sourceSets.main.java.srcDirs = ['util/src']

    dependencies {
//        compile project(':cts-support')
        compile project(':cts:common:util')
        compile AndroidSdk.N_MR1.coordinates
        compile "junit:junit:4.12"
    }
}

project(":cts:libs:deviceutil") {
    apply plugin: "java"

    sourceSets.main.java.srcDirs = ['src']

    dependencies {
        compile project(':cts-support')
        compile project(':cts:common:device-side')
        compile project(':cts:common:util')
        compile AndroidSdk.N_MR1.coordinates
    }
}

project(':cts:all') {
    task test
}

def BUILD_TOOLS = '/usr/local/google/home/christianw/Android/Sdk/build-tools/25.0.2'

project(":cts:tests").subprojects.each { ctsProject ->
    configure(ctsProject) {
        def isCommon = ctsProject.name == 'common'

        apply plugin: "java"

        def generatedSrcDir = new File("${buildDir}/generated/src/java")

        if (isCommon) {
            sourceSets {
                main.java.srcDirs = ['src', generatedSrcDir]
            }
        } else {
            sourceSets {
                test.java.srcDirs = ['src', generatedSrcDir]
            }
        }

        task aapt(type: Exec) {
            onlyIf { new File(project.projectDir, 'res').isDirectory() }

            doFirst { generatedSrcDir.mkdirs() }

            commandLine "$BUILD_TOOLS/aapt",
                    'package',
                    '-S', 'res',
                    '-M', 'AndroidManifest.xml',
                    '--non-constant-id',
                    '-J', generatedSrcDir.toString(),
                    '-m',
                    '-I', '/usr/local/google/home/christianw/Android/Sdk/platforms/android-25/android.jar'
        }

        task renderscript(type: Exec) {
            def files = fileTree(dir: 'src').matching { include '**/*.rs' }

            onlyIf { files.any() }

            workingDir generatedSrcDir

            def cmd = ["$BUILD_TOOLS/llvm-rs-cc",
                       '-I', "$BUILD_TOOLS/renderscript/include",
                       '-I', "$BUILD_TOOLS/renderscript/clang-include"]
            cmd += files.files*.toString()

            commandLine(*cmd)
        }

        tasks['compileJava'].dependsOn('aapt', 'renderscript')

        dependencies {
            compile project(":cts-support")
            compile project(":robolectric")
            compile project(":cts:libs:deviceutil")
            compile project(":cts:common:device-side")
            compile AndroidSdk.N_MR1.coordinates

            // Testing dependencies
            compile "junit:junit:4.12"
//        testCompile "org.assertj:assertj-core:2.6.0"
            compile "org.mockito:mockito-core:2.5.4"

            ctsProject.subprojects.each { p ->
                compile project(p.path)
            }
        }

        test {
            testLogging {
                showStandardStreams = true
            }
        }

        findProject(':cts:all').tasks['test'].dependsOn(tasks['test'])
    }
}

[
        ':cts:tests:tests/car',
        ':cts:tests:tests/dpi2',
        ':cts:tests:tests/keystore',
        ':cts:tests:tests/location',
        ':cts:tests:tests/media',
        ':cts:tests:tests/net',
        ':cts:tests:tests/netsecpolicy',
        ':cts:tests:tests/networksecurityconfig',
        ':cts:tests:tests/os',
        ':cts:tests:tests/renderscript',
        ':cts:tests:tests/rsblas',
        ':cts:tests:tests/rscpp',
        ':cts:tests:tests/security',
        ':cts:tests:tests/shortcutmanager',
        ':cts:tests:tests/telecom',
        ':cts:tests:tests/telecom2',
        ':cts:tests:tests/telecom3',
        ':cts:tests:tests/telephony',
        ':cts:tests:tests/text',
        ':cts:tests:tests/toast',
        ':cts:tests:tests/toastlegacy',
        ':cts:tests:tests/uidisolation',
        ':cts:tests:tests/webkit',
        ':cts:tests:tests/widget',
].forEach { name ->
    project(name) {
        renderscript { onlyIf { false } }
        compileTestJava { onlyIf { false } } // relies on missing classes
    }
}

project(':cts:all') {
    task assemble {
        dependsOn project(':cts:tests').subprojects.findAll { it.name != 'common' }.collect { it.tasks['assemble'] }
    }
}
